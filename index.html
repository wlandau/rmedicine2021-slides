<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Target Markdown and stantargets for Bayesian model validation pipelines</title>
    <meta charset="utf-8" />
    <meta name="author" content="Will Landau" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link href="index_files/remark-css/default.css" rel="stylesheet" />
    <link href="index_files/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Target Markdown and stantargets for Bayesian model validation pipelines
### Will Landau

---


&lt;style&gt;
.inverse {
background-color: transparent;
text-shadow: 0 0 0px transparent;
}
.title-slide {
vertical-align: bottom !important; 
text-align: center !important;
}
.title-slide h1 {
position: absolute;
top: 0;
left: 0;
right: 0;
width: 100%;
line-height: 4em;
color: #666666;
font-size: 2em;
}
.title-slide h3 {
line-height: 2em;
color: #666666;
}
.title-slide {
background-color: white;
background-image: url('images/logos.png');
background-repeat: no-repeat;
background-size: 50%;
}
.remark-slide-content:after {
content: "Copyright Eli Lilly and Company";
position: absolute;
bottom: -5px;
left: 10px;
height: 40px;
width: 100%;
font-family: Helvetica, Arial, sans-serif;
font-size: 0.7em;
color: gray;
background-repeat: no-repeat;
background-size: contain;
}
.remark-slide-content .nocopyright:after {
content: "";
}
.small {
  font-size: 65%;
}
&lt;/style&gt;





## Demanding computation in R

* **Bayesian data analysis: JAGS, Stan, NIMBLE, `greta`**
* Deep learning: `keras`, `tensorflow`, `torch`
* Machine learning: `tidymodels`
* PK/PD: `nlmixr`, `mrgsolve`
* Clinical trial simulation: `rpact`, `Mediana`
* Statistical genomics
* Social network analysis
* Permutation tests
* Database queries: `DBI`
* ETL on large data

---

## Overlooked realities of long computation

![](./images/realities.png)

---

## Workflows have interconnected steps.

![](./images/workflow.png)

---

## If you change code or data...

![](./images/change.png)

---

## ...the downstream steps are no longer valid.

![](./images/downstream.png)

---

## Dilemma: short runtimes or reproducible results?

![](./images/decisions.png)

---

## Let a pipeline tool figure out what to rerun.

![](./images/pipeline_graph.png)

* Save time while ensuring computational reproducibility.
* Automatic parallel/distributed computing based on the directed acyclic graph.

---

## Pipeline tools

&lt;center&gt;
&lt;img src="./images/infographic.png" height = "125px"&gt;
&lt;/center&gt;

* Existing pipeline tools: https://github.com/pditommaso/awesome-pipeline
* Most are language-agnostic or designed for Python or the shell.

## {targets}

* Fundamentally designed for R.
* Supports a clean, modular, function-oriented programming style.
* Abstracts files as R objects and automatically manages data.
* Surpasses the permanent limitations of its predecessor, [`drake`](https://github.com/ropensci/drake): &lt;https://books.ropensci.org/targets/drake.html&gt;.
* Continuation of the ideas from `remake` by Rich FitzJohn: &lt;https://github.com/richfitz/remake&gt;.

---

## Challenge

* Most pipelines have a lot of user-side code.
* `targets` prefers code to be in pure user-defined functions.
* Leads to a lot of user-side software engineering.

## Solutions for Bayesian workflows

* `stantargets` reduces the volume of user-side code and automates entire validation pipelines: &lt;https://docs.ropensci.org/stantargets/articles/simulation.html&gt;
* Target Markdown is a comfortable interface for interactive prototyping and non-interactive pipeline construction: &lt;https://books.ropensci.org/targets/markdown.html&gt;
  
---

## Extending {targets}

![](./images/targetopia.png)

---

## Target factories

* A target factory is a reusable function that creates target objects.


```r
target_factory &lt;- function(file) {
  list(
    tar_target_raw("file", file, format = "file", deployment = "main"),
    tar_target_raw("data", quote(read_data(file)), format = "fst_tbl", deployment = "main"),
    tar_target_raw("model", quote(run_model(data)), format = "qs")
  )
}
```

---

## Target factories simplify pipeline construction.


```r
# _targets.R
library(targets)
library(yourExamplePackage)
list(
  target_factory("data.csv")
)
```


```r
# R console
tar_manifest(fields = command)
#&gt; # A tibble: 3 x 2
#&gt;   name  command          
#&gt;   &lt;chr&gt; &lt;chr&gt;            
#&gt; 1 file  "\"data.csv\""   
#&gt; 2 data  "read_data(file)"           
#&gt; 3 model "run_model(data)"
```

---

## Example: {stantargets}

&lt;center&gt;
&lt;image src="./images/stantargets.png" height = "300px"&gt;
&lt;/center&gt;

* Easy pipeline construction for Stan statistical models.
* Uses R packages [`cmdstanr`](https://mc-stan.org/cmdstanr/) and [`posterior`](https://mc-stan.org/posterior/).

---

## About Stan

* Probabilistic programming language ([Carpenter et al. 2017](https://www.jstatsoft.org/article/view/v076i01)).
* Markov chain Monte Carlo (MCMC) with HMC and NUTS.
    * Often more efficient than Gibbs sampling.
    * Flexible specification of posterior distributions.
    * Indifferent to conjugacy.
* Variational inference (ADVI)
* Penalized MLE (L-BFGS)

---

## Example: Bayesian longitudinal model for clinical trials

&lt;!--
$$
\begin{aligned}
&amp; y \sim \text{MVN}(X_{(n \cdot t) \times p} \beta, \ I_{n \times n} \otimes \Sigma_{t \times t} ) \\
&amp; \qquad \beta \sim \text{MVN} (0, 10^2 I_{p \times p})\\
&amp;  \qquad \Sigma_{t \times t} = \left (I_{t \times t} \sigma \right ) \Lambda_{t \times t} \Lambda_{t \times t}' \left (I_{t \times t} \sigma \right ) \\
&amp; \qquad \qquad \sigma_1, \ldots, \sigma_t \stackrel{\text{ind}}{\sim} \text{Cauchy}^+(0, 5) \\
&amp; \qquad \qquad \Lambda_{t \times t}\Lambda_{t \times t}' \sim \text{LKJ}(\text{shape} = 1, \text{order} = t)
\end{aligned} 
$$
--&gt;

![](./images/model.png)

* A common variant of this model uses inverse-Wishart for the covariance, which induces troublesome prior relationships among covariance components ([Alvarez et al. 2016](https://arxiv.org/abs/1408.4050)).
* The above LKJ-based model could help refine some existing models currently used on real clinical trial data. 
* **But first, we need to ensure the above model is implemented correctly.**

---

## Interval-based validation study

* For several independent replications:
    * Simulate data from the prior predictive distribution.
    * Fit the model to the simulated data using MCMC.
    * Calculate x% posterior intervals for each scalar parameter.
* For each of scalar parameter, roughly x% of the posterior intervals should cover the corresponding parameter draws from the joint prior.
* 50% and 95% are common choices for x%.
* Simulation-based calibration extends this idea further ([Cook et al. 2006](https://www.jstor.org/stable/27594203); [Talts et al. 2020](https://arxiv.org/abs/1804.06788)).

---

## Write the pipeline in Target Markdown

* R Markdown interface for `targets`.
* Interactive mode for prototyping and emulation.
* Non-interactive mode for pipeline construction.
* Template available through RStudio.

&lt;center&gt;
&lt;img src="./images/target_markdown.png" height="350" align = "center"&gt;
&lt;/center&gt;

---

## One function to simulate prior predictive data

* No other user-defined function required.
* Interactive mode emulates `targets`' behavior in your local environment.

&lt;center&gt;
&lt;img src="./images/target_markdown_globals.png" height = "400"&gt;
&lt;/center&gt;

---

## Simulation and MCMC with {stantargets}

* Non-interactive mode writes the `_targets.R` file and supporting scripts.
* Declares targets but does not run them.

&lt;center&gt;
&lt;img src="./images/target_markdown_targets.png" height = "400"&gt;
&lt;/center&gt;

---

## Simple target for convergence diagnostics

&lt;center&gt;
&lt;img src="./images/target_markdown_convergence.png"&gt;
&lt;/center&gt;

---

## Simple target for coverage statistics

&lt;center&gt;
&lt;img src="./images/target_markdown_coverage.png"&gt;
&lt;/center&gt;

---

## Optional R code chunk to run the pipeline

* Either run the pipeline in an ordinary R code chunk (below) or invoke `tar_make_clustermq()` outside the R Markdown report.

&lt;center&gt;
&lt;img src="./images/target_markdown_run.png"&gt;
&lt;/center&gt;

---


## Optional R code chunks to read the results

&lt;center&gt;
&lt;img src="./images/target_markdown_results.png"&gt;
&lt;/center&gt;

---


## First run takes a long time.

&lt;center&gt;
&lt;img src="./images/tar_make_clustermq.png"&gt;
&lt;/center&gt;

---

## Subsequent runs skip up-to-date targets.

&lt;center&gt;
&lt;img src="./images/tar_make_clustermq_skip.png"&gt;
&lt;/center&gt;

---

## Convergence diagnostics

&lt;center&gt;
&lt;img src="./images/tar_read_convergence.png"&gt;
&lt;/center&gt;

---

## Coverage is nominal.

&lt;center&gt;
&lt;img src="./images/tar_read_coverage.png" height = "500"&gt;
&lt;/center&gt;

---

## Thanks

* `stantargets`: Melina Vidoni served as editor and Krzysztof Sakrejda and Matt Warkentin served as reviewers during the rOpenSci software review process.
* Target Markdown: Christophe Dervieux and Yihui Xie provided crucial advice during initial development.
* Richard Payne and Karen Price reviewed this Bayesian model validation project.

---

## Resources

Resource | Link
---|---
Slides | &lt;https://wlandau.github.io/rmedicine2021-slides/&gt;
Slide source | &lt;https://github.com/wlandau/rmedicine2021-slides&gt;
Pipeline report | &lt;https://wlandau.github.io/rmedicine2021-pipeline/&gt;
Pipeline source | &lt;https://github.com/wlandau/rmedicine2021-pipeline&gt;
`targets` | &lt;https://docs.ropensci.org/targets/&gt;
Target Markdown | &lt;https://books.ropensci.org/targets/markdown.html&gt;
`stantargets` |  &lt;https://docs.ropensci.org/stantargets/&gt;
Stan | &lt;https://mc-stan.org/&gt;
`cmdstanr` | &lt;https://mc-stan.org/cmdstanr/&gt;
`posterior` | &lt;https://mc-stan.org/posterior/&gt;

---

## References

.small[
* Alvarez, Ignacio, Jarad Niemi, and Matt Simpson. 2016. “Bayesian Inference for a Covariance Matrix.” http://arxiv.org/abs/1408.4050.
* Bürkner P, Gabry J, Kay M, Vehtari A (2021). “posterior: Tools
for Working with Posterior Distributions.” R package version
0.1.6, &lt;https://mc-stan.org/posterior&gt;.
* Carpenter, Bob, Andrew Gelman, Matthew D. Hoffman, Daniel Lee, Ben Goodrich, Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. 2017. Stan: A probabilistic programming language. Journal of Statistical Software 76(1). [10.18637/jss.v076.i01](https://www.jstatsoft.org/article/view/v076i01).
* Cook, Samantha R., Andrew Gelman, and Donald B. Rubin. 2006. “Validation of Software for Bayesian Models Using Posterior Quantiles.” Journal of Computational and Graphical Statistics 15 (3): 675–92. http://www.jstor.org/stable/27594203.
* Gabry, Jonah, and Rok Češnovar (2021). cmdstanr: R Interface
  to 'CmdStan'. https://mc-stan.org/cmdstanr,
  https://discourse.mc-stan.org.
* Gelman, Andrew. 2006. “Prior distributions for variance parameters in hierarchical models (comment on article by Browne and Draper).” Bayesian Analysis 1 (3): 515–34. https://doi.org/10.1214/06-BA117A.
* Gelman, Andrew, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari, and Donald B. Rubin. 2014. Bayesian Data Analysis. Edited by Francesca Dominici, Julian J. Faraway, Martin Tanner, and Jim idek. Third. CRC Press.
* Landau, William Michael. 2021a. “The Stantargets R Package: A Workflow Framework for Efficient Reproducible Stan-Powered Bayesian Data Analysis Pipelines.” Journal of Open Source Software 6 (60): 3193. https://doi.org/10.21105/joss.03193.
* ———. 2021b. “The Targets R Package: A Dynamic Make-Like Function-Oriented Pipeline Toolkit for Reproducibility and High-Performance Computing.” Journal of Open Source Software 6 (57): 2959. https://doi.org/10.21105/joss.02959.
* Schubert, Michael. 2019. “clustermq enables efficient parallelization of genomic analyses.” Bioinformatics 35 (21): 4493–95. https://doi.org/10.1093/bioinformatics/btz284.
* Talts, Sean, Michael Betancourt, Daniel Simpson, Aki Vehtari, and Andrew Gelman. 2020. “Validating Bayesian Inference Algorithms with Simulation-Based Calibration.” http://arxiv.org/abs/1804.06788.
* Xie, Yihui, J.J. Allaire, and Garrett Grolemund (2018). R Markdown: The Definitive Guide. Chapman and Hall/CRC. ISBN 9781138359338. https://bookdown.org/yihui/rmarkdown.
* Xie, Yihui, Christophe Dervieux, and Emily Riederer (2020). R Markdown Cookbook. Chapman and Hall/CRC. ISBN 9780367563837. https://bookdown.org/yihui/rmarkdown-cookbook.
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
